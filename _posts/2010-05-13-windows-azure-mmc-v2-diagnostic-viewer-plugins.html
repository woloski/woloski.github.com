--- 
layout: post
title: "Windows Azure MMC v2 \xE2\x80\x93 Diagnostic Viewer Plugins"
published: true
meta: {}

tags: 
- Azure
type: post
status: publish
---
<p>We’ve been working during the last couple of months with <a href="http://www.dunnry.com">Ryan Dunn</a> and <a href="http://www.davidaiken.com/">David Aiken</a> on various things related to Windows Azure management API. One of them, released yesterday was the <a href="http://code.msdn.microsoft.com/windowsazuremmc">Windows Azure MMC v2</a> (read <a href="http://dunnry.com/blog/2010/05/11/WindowsAzureMMCV2Released.aspx">Ryan’s post</a> about it) This version provides a significant amount of features compared to the first version. </p>  <p>Ryan covered pretty much of the features in this <a href="http://dunnry.com/blog/ct.ashx?id=351f9dc7-0c05-4202-8ef2-830491c36339&amp;url=http%3a%2f%2fdunnry.blob.core.windows.net%2fvideos%2fWindowsAzureMMC.wmv%3fsr%3db%26si%3dsc%26sig%3dY%252BOq2niX87LxaM6%252FBbUthD%252FpcUPvyItzGByTPfAq00Q%253D">15 minutes screencast</a>, so I will focus on the extensibility of the Windows Azure MMC. </p>  <p>The Windows Azure MMC has the following extensibility points:</p>  <ul>   <li>Adding a new module (i.e. a new node somewhere in the tree) </li>    <li>Adding a new diagnostic data viewer </li>    <li>Adding a new table storage viewer </li> </ul>  <p>One of the pieces that we enjoyed building with <a href="http://blogs.southworks.net/siacomuzzi">Sebastian</a> (aka Iaco) was the <strong>diagnostics data analysis</strong>. This functionality allows you to work with the data generated by the Windows Azure diagnostics infrastructure and it’s built using MEF and the MVVM pattern. If you want to create your own visualizer or viewer for diagnostic data, keep reading….</p>  <h2><strong>How to implement a diagnostics data viewer</strong></h2>  <p>We used MVVM pattern throughout the MMC (how we did that is long enough to write another blog post). So implementing a diagnostics plugin means in a few words: creating a ViewModel + UserControl, decorate the <strong>ViewModel</strong> with the <strong>ViewerExport </strong>attribute, derive from <strong>ViewerViewModelBase&lt;UserControlType&gt; </strong>and implement <strong>OnSearchAsync </strong>and <strong>OnSearchAsyncCompleted. </strong>These are the step by step instructions to do that. Download the code here: <a title="http://snipurl.com/mmcplugin" href="http://snipurl.com/mmcplugin">http://snipurl.com/mmcplugin</a></p>  <ol>   <li>First, open Visual Studio 2008 or 2010 and create a new <strong>WPF User Control Library</strong>.      <br />      <br /><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb.png" width="640" height="409" /></a>      <br /></li>    <li>Add references to the following dlls (all of them located %install_dir%\WindowsAzureMMC\release)</li>    <ul>     <li><strong>MicrosoftManagementConsole.Infrastructure</strong></li>      <li><strong>Microsoft.Samples.WindowsAzureMmc.Model</strong></li>      <li><strong>Microsoft.Samples.WindowsAzureMmc.ServiceManagement </strong></li>      <li><strong>System.CompositionModel.Composition         <br /></strong>        <br /><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image1.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb1.png" width="408" height="195" /></a>&#160;</li>   </ul>    <li>Right click on the project and add a new class called “<strong>SimpleAzureDiagnosticsEventViewer</strong>” and decorate it with the following attributes&#160; <br />       <br /><font face="consolas"><strong>[PartCreationPolicy(CreationPolicy.NonShared)]          <br />[ViewerExport(&quot;Simple Datagrid Azure Logs&quot;, ViewerType.WindowsAzureLogsViewer)]           <br /></strong>public class SimpleAzureDiagnosticsEventViewer        <br /></font></li>    <li>Derive the class from <strong>ViewerViewModelBase&lt;UserControl1&gt; [1]</strong>. The viewers must implement the <strong>IViewer</strong> interface but we provide this base class that helps with some infrastructure code.      <br />      <br /><font face="consolas">public class SimpleAzureDiagnosticsEventViewer : </font><strong><font face="consolas">ViewerViewModelBase&lt;UserControl1&gt;         <br /></font></strong></li>    <li>Override the <strong>OnSearchAsync</strong> and <strong>OnSearchAsyncCompleted</strong> methods      <br />      <br /><strong><font face="consolas">protected override System.Collections.IEnumerable OnSearchAsync(FilterCriteria criteria)         <br />{          <br />} </font></strong></li>    <p><strong><font face="consolas">protected override void OnSearchAsyncCompleted(SearchCompletedEventArgs args)         <br />{          <br />}          <br /></font></strong></p>    <li>Finally use the <strong>DataProvider</strong> [1] (service injected through the base class) to perform a search on the WindowsAzure Logs and fill the <strong>EventLogEntries </strong>collection (notice the RetrieveWindowsAzureLogsData)      <br /></li>    <p><strong><font face="consolas">public ObservableCollection&lt;WindowsAzureLogData&gt; EventLogEntries { get; set; } </font></strong></p>    <p><strong><font face="consolas">public SimpleAzureDiagnosticsEventViewer()         <br />{          <br />&#160;&#160;&#160; this.EventLogEntries = new ObservableCollection&lt;WindowsAzureLogData&gt;();          <br />} </font></strong></p>    <p><font face="consolas">protected override System.Collections.IEnumerable OnSearchAsync(Microsoft.Samples.WindowsAzureMmc.Model.Diagnostics.Analysis.FilterCriteria criteria)       <br />{        <br /></font><font face="consolas"><strong>&#160;&#160;&#160; return this.DataProvider.RetrieveWindowsAzureLogData(criteria);         <br /></strong>} </font></p>    <p><font face="consolas">protected override void OnSearchAsyncCompleted(SearchCompletedEventArgs args)       <br />{        <br /><strong>&#160;&#160;&#160; bool noData = (args.Result == null) || (((IEnumerable&lt;WindowsAzureLogData&gt;)args.Result).Count&lt;WindowsAzureLogData&gt;() == 0); </strong></font></p>    <p><font face="consolas"><strong>&#160;&#160;&#160; if (!noData)         <br />&#160;&#160;&#160; {          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var result = (IEnumerable&lt;WindowsAzureLogData&gt;)args.Result;          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; foreach (var item in result)          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.EventLogEntries.Add(item);          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }          <br />&#160;&#160;&#160; }          <br /></strong>}</font>      <br /></p>    <li>Finally, put some XAML on the usercontrol bounded to the EventLogEntries collection. In this case we are using the WPF Toolkit datagrid. Notice the <strong>ItemsSource</strong> property bounded to <strong>EventLogEntries</strong>      <br /></li>    <p><font face="consolas">&lt;UserControl x:Class=&quot;SimpleDiagnosticPlugin.UserControl1&quot;       <br />&#160;&#160;&#160; xmlns=&quot;</font><a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;"><font face="consolas">http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</font></a>      <br /><font face="consolas">&#160;&#160;&#160; xmlns:x=&quot;</font><a href="http://schemas.microsoft.com/winfx/2006/xaml&quot;"><font face="consolas">http://schemas.microsoft.com/winfx/2006/xaml&quot;</font></a>      <br /><font face="consolas">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; xmlns:toolkit=&quot;clr-namespace:Microsoft.Windows.Controls;assembly=WPFToolkit&quot;       <br />&#160;&#160;&#160; &gt;        <br />&#160;&#160;&#160; &lt;Grid&gt;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;toolkit:DataGrid AutoGenerateColumns=&quot;False&quot; Name=&quot;EventsGrid&quot; ItemsSource=&quot;{Binding EventLogEntries}&quot;         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Height=&quot;300&quot; VerticalAlignment=&quot;Top&quot; IsReadOnly=&quot;True&quot;&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;toolkit:DataGrid.Columns&gt;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;toolkit:DataGridTextColumn Header=&quot;Level&quot; Width=&quot;Auto&quot;&#160; Binding=&quot;{Binding LogLevel}&quot; /&gt;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;toolkit:DataGridTextColumn Header=&quot;Message&quot; Width=&quot;Auto&quot; Binding=&quot;{Binding Message}&quot; /&gt;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;toolkit:DataGridTextColumn Header=&quot;Date and Time&quot; Width=&quot;Auto&quot; Binding=&quot;{Binding EventDateTime}&quot; /&gt;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/toolkit:DataGrid.Columns&gt;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/toolkit:DataGrid&gt;        <br />&#160;&#160;&#160; &lt;/Grid&gt;        <br />&lt;/UserControl&gt;        <br /></font></p>    <li>Compile and grab the output dll and copy to %install_dir%\WindowsAzureMMC\release.</li>    <li>If you have the MMC open, click on <strong>Refresh Plugins </strong>if not open it and browse to the diagnostics node.      <br /><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image2.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb2.png" width="640" height="455" /></a> </li>    <li>Click on the Windows Azure Logs dropdown and the new plugin will appear. Select the new plugin and the search will start. The MMC will call the Search method of the IViewer which will end up calling OnSearchAsync with the filter defined.     <br />&#160; <br /><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image3.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb3.png" width="583" height="480" /></a>&#160;&#160; <br /></li>    <li>If you choose Excel this is what happens     <br />      <br /><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image4.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb4.png" width="605" height="480" /></a>&#160;</li> </ol>  <p>The user experience is probably not the best, we had to make it generic enough with the usual time constraints and the MMC UX constraints. Things can be much better, hopefully in a v3.</p>  <p><strong><em>I will leave you with some food for thought…. how hard would be to create a plugin that mixes the perf data and event logs data? </em></strong></p>  <p><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image5.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb5.png" width="640" height="347" /></a> </p>  <p><strong>[1] </strong>The ViewerViewModelBase class. Plugins should derive from it.</p>  <p><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image6.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb6.png" width="640" height="271" /></a></p>  <p><strong>[2] </strong>The IDataProvider interface. The default implementation DataProvider is a wrapper over the diagnostics API that queries the diagnostics tables</p>  <p><a href="http://blogs.southworks.net/mwoloski/files/2010/05/image7.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/05/image-thumb7.png" width="640" height="192" /></a> </p>  <p>Download the code of this simple plugin from <a title="http://snipurl.com/mmcplugin" href="http://snipurl.com/mmcplugin">http://snipurl.com/mmcplugin</a></p>
