--- 
layout: post
title: "Poor man\xE2\x80\x99s memcached for Windows Azure"
published: true
meta: {}

tags: 
- Azure
- Emerging Technology
type: post
status: publish
---
<p><strong>UPDATE: After reading this post you can read about the <a href="http://blogs.southworks.net/mwoloski/2010/06/27/that-solution-doesnt-scale/">scalability of this solution</a>, posted based on some comments. </strong></p>  <p>Part of working with the <a href="http://wag.codeplex.com">Windows Azure guidance</a> team is not only about writing but it’s also about helping customers and understanding real life problems. This help us validate and enrich the content.</p>  <p>One of the customers <a href="http://blogs.southworks.net/ejadib">we</a> are helping has an hybrid solution in Windows Azure where there is a backend running on-premises that pushes information to a frontend running on Windows Azure in ASP.NET. This information is stored in blob storage and then served from the web role. To avoid going every time to the blob storage, though, they want to cache the information. But whenever you cache, you have to handle the expiration of the item you are caching, otherwise it never gets updated. That’s one option, cache it for X minutes. But the ideal would be to control the caching and whenever the information gets stale, update the cache. This is <a href="http://nhforge.org/blogs/nhibernate/archive/2009/04/17/tuning-nhibernate-tolerant-querycache.aspx">easy if you use an ORM like NHibernate</a> or if you are using <a href="http://msdn.microsoft.com/en-us/library/system.web.caching.sqlcachedependency.aspx">SqlCommands and SqlCacheDependency</a> or if you use something like memcached or the AppFabric velocity. However it gets more difficult if you have other kind of resources to cache and if the web application runs in a farm.</p>  <h3>Using Windows Azure queues to invalidate ASP.NET Cache</h3>  <p>Maybe you need something smaller. This is what I implemented, I just posted <a href="http://snipurl.com/queuecache">on git</a> two classes that can be used in a Windows Azure Web Role running ASP.NET as a very basic distributed caching mechanism. The following picture shows how it works at a high level. </p>  <p><a href="http://blogs.southworks.net/mwoloski/files/2010/06/image4.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb3.png" width="544" height="471" /></a>&#160;</p>  <h2>Usage</h2>  <p>Using it requires two things</p>  <ol>   <li>Start the monitor (that listens to the queue). Write this code either in the <strong>WebRole entry point </strong>or in the <strong>Global.asax Applicaiton_Start</strong>.       <br />      <br /><a href="http://blogs.southworks.net/mwoloski/files/2010/06/image5.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb4.png" width="362" height="18" /></a>       <br /></li>    <li>Use the regular ASP.NET Cache API but providing the <strong>CloudQueueCacheDependency </strong>with a key<a href="http://blogs.southworks.net/mwoloski/files/2010/06/image6.png">        <br />        <br /><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb5.png" width="597" height="76" /></a> </li> </ol>  <h2>Example</h2>  <p>I uploaded this to Windows Azure and provisioned two instances of a web role and this is the result</p>  <table border="0" cellspacing="0" cellpadding="2" width="600"><tbody>     <tr>       <td valign="top" width="300">Web Role <strong>instance 0</strong></td>        <td valign="top" width="300">Web Role <strong>instance 1</strong></td>     </tr>      <tr>       <td valign="top" width="300"><a href="http://blogs.southworks.net/mwoloski/files/2010/06/image7.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb6.png" width="317" height="273" /></a></td>        <td valign="top" width="300"><a href="http://blogs.southworks.net/mwoloski/files/2010/06/image9.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb7.png" width="338" height="272" /></a> </td>     </tr>   </tbody></table>  <p>By sending a message to the <strong><em>invalidatecache-distributedcache-web-in-0</em></strong> queue we invalidate the item “test” in cache in the 0 instance. This corresponds to the Cache1 label. If we send “test2” message, we would invalidate the Cache2 item.</p>  <p><a href="http://blogs.southworks.net/mwoloski/files/2010/06/image10.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb8.png" width="640" height="289" /></a> </p>  <p>The cache expired and an updated datetime is shown.</p>  <table border="0" cellspacing="0" cellpadding="2" width="600"><tbody>     <tr>       <td valign="top" width="300">Web Role <strong>instance 0</strong></td>        <td valign="top" width="300">Web Role <strong>instance 1</strong></td>     </tr>      <tr>       <td valign="top" width="300"><a href="http://blogs.southworks.net/mwoloski/files/2010/06/image11.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb9.png" width="336" height="290" /></a></td>        <td valign="top" width="300"><a href="http://blogs.southworks.net/mwoloski/files/2010/06/image13.png"><img border="0" alt="image" src="http://blogs.southworks.net/mwoloski/files/2010/06/image-thumb10.png" width="360" height="291" /></a> </td>     </tr>   </tbody></table>    <h2>Conclusion</h2>  <p>By using this technique you can have a distributed system where the backend makes an update on-premises, pushes something to the cloud and it invalidates the cache by posting a message to a queue. I didn’t worry too much about being fault tolerant in the monitor simply because in the worst case the item keeps alive in the cache and you can repost a message.</p>  <p>Download the code from <a href="http://snipurl.com/queuecache">here</a></p>  <p><strong>DISCLAIMER</strong>: the code is provided as-is and has not been tested under stress conditions. Use it at your own risk.</p>
