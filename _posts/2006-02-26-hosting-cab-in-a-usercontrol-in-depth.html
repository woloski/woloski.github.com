--- 
layout: post
title: Hosting CAB in a UserControl - In depth
published: true
meta: {}

tags: 
- CAB
type: post
status: publish
---
<p>In the <a href="/blogs/matiaswoloski/archive/2006/02/26/HostingCAB.aspx">previous post</a>,    <br />I've described an approach to host a CAB application in Outlook, Word,    <br />or any other .net-compatible application. In this post, I will analyze    <br />the internals of CAB as well as the code I had to write to implement    <br />that.</p>  <p>In a normal <a href="http://codegallery.gotdotnet.com/cab">CAB</a> application (<b>FormShellApplication</b>) the    <br /><span style="font-style: italic">Run</span> method initialize the whole CAB infrastructure, the root work item and the    <br />modules.</p>  <p class="MsoNormal">   <br />Every CAB Application inherits from the <b>CabApplication</b>    <br />class. This is the &#226;&#8364;&#339;heart&#226;&#8364;¬ù of CAB, where all the initialization takes place.</p>  <p>The <b><i>Run</i></b> method of <b>CabApplication</b> could    <br />be separated in three stages:</p>  <p class="MsoNormal"><a href="http://blogs.southworks.net/mwoloski/files/2008/06/hcab1.jpg"><img height="364" alt="hcab1" src="http://blogs.southworks.net/mwoloski/files/2008/06/hcab1-thumb.jpg" width="453" border="0" /></a> </p>  <ol style="margin-top: 0cm" type="1">   <li class="MsoNormal">These lines of code will add the ObjectBuilder builder     <br />strategies, the required services, will build up and initialize the root      <br />workitem and finally it will run it </li>    <li class="MsoNormal">The second part will execute the Start method. This method     <br />is abstract and must be overridden in derived applications. The <b>FormShellApplication</b>      <br />will override it in order to start the Winforms application using the      <br />Shell as the main form       <p class="MsoNormal"><span>protected</span><span> <span style="color: blue">override</span> <span style="color: blue">void</span> Start()</span>        <p>{</p>        <p><span style="color: teal">&#160;&#160;&#160; Application</span>.Run(Shell);</p>        <p>}</p>     </p>      <p class="MsoNormal" style="margin-left: 18pt"><b>This line of code will start         <br />the message pump and the winforms application will start listening UI messages          <br />until the shell is closed. When that happens, part 3 is executed</b>        <p></p>     </p>   </li>    <li class="MsoNormal">The disposal of the root workitem and any visualizer     <br />configured happens here. </li> </ol>  <p class="MsoNormal"><b><font size="4">What happens when you want to host CAB in a UserControl       <br />and not in a regular Form?</font> </b></p>  <p class="MsoNormal">The problem is that the message pump has already been   <br />created by the host application: either a Winforms (not designed with CAB), an    <br />Outlook addin, a Word Document, etc. That means that the <i>Start</i> method    <br />cannot execute <i>Application.Run(Shell)</i>. However, <b>if we don&#226;&#8364;&#8482;t execute Application.Run,     <br />the thread will keep executing and will dispose the workitem (part 3)</b></p>  <p class="MsoNormal"><font size="4"><b>How this could be solved?</b></font></p>  <p class="MsoNormal">We need to delay the disposal of the root work item until we   <br />decide it is ok to dipose it. To achieve this, a new workitem need to be    <br />created. This root workitem will override the base <i>Dispose(bool disposing)</i>    <br />method in order to have control over when the Dispose needs to be executed.</p>  <p class="MsoNormal"><span>public</span><span> <span style="color: blue">class</span> <span style="color: teal">UserControlWorkItem</span>      <br />: <span style="color: teal">WorkItem</span></span>    <p>{</p>    <p><span style="color: blue">&#160;&#160;&#160; private</span> <span style="color: blue">bool</span>      <br />_dispose = <span style="color: blue">false</span>;</p>    <p><span style="color: blue"></span>      <p>public</p>  <span style="color: blue">void</span>      <br />DoDispose()</p>    <p>{</p>    <p>_dispose = <span style="color: blue">true</span>;</p>    <p>Dispose(<span style="color: blue">true</span>);<span style="color: teal"></span>      <p>GC</p> .SuppressFinalize(<span style="color: blue">this</span>);</p>    <p>}</p> </p>  <p class="MsoNormal"><span><span style="color: blue">&#160;&#160;&#160; protected</span> <span style="color: blue">override</span>      <br /><span style="color: blue">void</span> Dispose(<span style="color: blue">bool</span>      <br />disposing) {</span>    <p><span style="color: blue">&#160;&#160;&#160;&#160;&#160;&#160;&#160; if</span> (_dispose) {</p>    <p><span style="color: blue">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; base</span>.Dispose(disposing);</p>    <p>}</p>    <p>}</p>    <p>}</p> </p>  <p class="MsoNormal">Then, the <b>UserControlShellApplication</b> will be defined    <br />with the following code. Note the <i>TWorkItem</i> being of type <i>UserControlWorkItem</i>    <br />and the <i>TUserControlShell</i> of type <i>UserControl</i>.</p>  <p class="MsoNormal"><span>     <br /></span></p>  <p class="MsoNormal"><span>public</span><span> <span style="color: blue">class</span> <span style="color: teal">UserControlShellApplication</span> : <span style="color: teal">WindowsFormsApplication</span></span>    <p><span style="color: blue">&#160;&#160;&#160; where</span> TWorkItem : <span style="color: teal">UserControlWorkItem</span>,      <br /><span style="color: blue">new</span>()</p>    <p><span style="color: blue">&#160;&#160;&#160; where</span> TUserControlShell : <span style="color: teal">UserControl</span>, <span style="color: blue">new</span>()</p>    <p>{</p>    <p><span style="color: blue">&#160;&#160;&#160; protected</span> <span style="color: blue">override</span>      <br /><span style="color: blue">void</span> Start()</p>    <p>{</p>    <p>}</p>    <p><span style="color: blue"></span>      <p>public</p>  <span style="color: blue">void</span>      <br />Dispose() {</p>    <p>RootWorkItem.DoDispose();</p>    <p>}</p> </p>  <p class="MsoNormal"><span>&#160;<span style="color: blue">&#160;&#160; public</span> TUserControlShell UserControlShell {</span>    <p><span style="color: blue">&#160;&#160;&#160;&#160;&#160;&#160;&#160; get</span> { <span style="color: blue">return</span> <span style="color: blue">base</span>.Shell; }</p>    <p>}</p>    <p>}</p> </p>  <p class="MsoNormal">Finally, we need to host the CAB application in a   <br />UserControl. This works just as a container and it is different from the    <br />UserControl that will act as a Shell. The UserControl will host an instance of <b>UserControlShellApplication</b>    <br />and will execute the <i>Run</i> method. Also, when the <b>UserControlHost</b>    <br />is disposed it will also dispose the <b>UserControlShellApplication</b> that    <br />will finally dispose the <b>UserControlWorkItem</b>.</p>  <p class="MsoNormal"><span>public</span><span> <span style="color: blue">partial</span> <span style="color: blue">class</span> <span style="color: teal">UserControlHost</span> : <span style="color: blue">UserControl</span>      <p>where</p>  TUserControlShellApplication : <span style="color: teal">UserControlShellApplication</span>,      <br /><span style="color: blue">new</span>()</span>    <p><span style="color: blue">&#160;&#160;&#160; where</span> TUserControlShell : <span style="color: teal">UserControl</span>, <span style="color: blue">new</span>()</p>    <p>{</p>    <p>protected</p>   <span> <span style="color: blue">virtual</span> <span style="color: blue">void</span> Run()</span>    <p>{</p>    <p>_cabApp = <span style="color: blue">new</span> TUserControlShellApplication();</p>    <p>_cabApp.Run();</p>    <p>_cabApp.UserControlShell.Dock = <span style="color: teal">DockStyle</span>.Fill;</p>    <p><span style="color: blue">&#160;&#160;&#160;&#160;&#160;&#160;&#160; this</span>.Controls.Add(_cabApp.UserControlShell);</p>    <p>OnStarted(<span style="color: teal">EventArgs</span>.Empty);</p>    <p>}</p> </p>  <p class="MsoNormal"><span>&#160;&#160;&#160; protected</span><span> <span style="color: blue">override</span> <span style="color: blue">void</span>      <br />Dispose(<span style="color: blue">bool</span> disposing)</span>    <p>{<span style="color: blue"></span>      <p>if</p>  (disposing) {</p>    <p>_cabApp.Dispose();</p>    <p>}</p>    <p><span style="color: blue">&#160;&#160;&#160;&#160;&#160;&#160;&#160; base</span>.Dispose(disposing);</p>    <p>}</p> </p>  <p>&#226;&#8364;&#166;</p>  <p><span>}</span></p>  <p class="MsoNormal"><b>Note</b>: as shown in part 3 the Visualizer is also    <br />disposed. The same approach applies to the visualizer.</p>
