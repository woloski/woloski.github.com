--- 
layout: post
title: Authorization Manager (AzMan) handler for EDRA and MBI 3.0
published: true
meta: {}

tags: 
- MBI
type: post
status: publish
---
<p></p>  <p>Recently, I had to get deep on <a href="http://www.microsoft.com/technet/prodtechnol/windowsserver2003/technologies/management/athmanwp.mspx">AzMan</a> for a project. This tool helps you to manage operation and roles for a custom application. It runs on Windows 2000, Windows 2003 and Windows XP which developers generally use. Just install the <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=c16ae515-c8f4-47ef-a1e4-a8dcbacff8e3&amp;DisplayLang=en">Windows Server 2003 Administration Tools Pack</a> and you'll get an MMC snap in like this</p>  <br />  <p><a href="http://blogs.southworks.net/mwoloski/files/2008/06/azman.gif"><img height="406" alt="azman" src="http://blogs.southworks.net/mwoloski/files/2008/06/azman-thumb.gif" width="420" border="0" /></a> </p>  <br />  <p>In a nutshell, AzMan allows you define Roles, Tasks and Operations. Operation is the atomic unit of AzMan. In terms of <a href="http://workspaces.gotdotnet.com/shadowfx">EDRA</a> or <a href="http://workspaces.gotdotnet.com/mbi">MBI</a> an operation will map to a Business Action. This way we can group operations in a task. For example, the system actions in MBI could be grouped all together in a task System Actions, and then we can define a role that has access to that task.</p>  <br />  <p>Task could nest task or operations and roles could nest roles, task and operations. This gives you a lot of flexibility to manage authorization for your app.</p>  <br />  <p>Now, the issue is how we can integrate this beatiful UI with our services. <a href="http://www.microsoft.com/technet/prodtechnol/windowsserver2003/technologies/management/athmanwp.mspx">AzMan</a> has a COM api available via Interop to .Net, that exposes the whole functionality. We are intereseted in one method specially which is the AccessCheck. This method will check authorization of a user against an operation</p>  <br />  <p><span>result <span>=</span> context.AccessCheck( <span>&quot;operation&quot;</span> )</span></p>  <br />  <p>In terms of <a href="http://workspaces.gotdotnet.com/shadowfx">EDRA</a> or <a href="http://workspaces.gotdotnet.com/mbi">MBI</a>, we need to grant or revoke access to services or actions. We have the concept of pipelines and filters (handlers) which give us lot of flexibilty and extensibility. What we should do is create a handler and put it in the interface pipeline (in MBI there is a single action pipeline, so we should replace the common Authorization handler with this one). The handler will do the AccessCheck and it will throw an exception wheter the user has access or not to execute a given service action.</p>  <br />  <p>The type of the EDRA handler will be an Atomic one, because we just need to intercept on the request in the interface, cutting any bad request from the ground. Here is the code for the Execute method of the handler (the MBI version)</p>  <br />  <p><span><span>public</span> <span>void</span> Execute(IContext context)      <br />{      <br />&#160;&#160;&#160; Command cmd <span>=</span> ContextHelper.GetCommand( context );      <br />&#160;&#160;&#160; <span>bool</span> authorize <span>=</span> <span>true</span>;      <br />&#160;&#160;&#160; IAzApplication azApp <span>=</span> <span>null</span>;      <br />&#160;&#160;&#160; IAzClientContext azContext <span>=</span> <span>null</span>;      <br />      <br />&#160;&#160;&#160; <span>foreach</span>( <span>string</span> excludedAction <span>in</span> _config.ExcludedActions )       <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span>if</span> ( excludedAction == cmd.Action )       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span>return</span>;      <br />&#160;&#160;&#160; }      <br />      <br />&#160;&#160;&#160; <span>string</span> userName <span>=</span> Thread.CurrentPrincipal.Identity.Name;      <br />&#160;&#160;&#160; <span>// check user exists for the application</span>      <br />&#160;&#160;&#160; <span>try</span>       <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; azContext <span>=</span> GetClientContextFromName( userName, _config.ApplicationName, <span>out</span> azApp );      <br />&#160;&#160;&#160; }      <br />&#160;&#160;&#160; <span>catch</span>       <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; authorize <span>=</span> <span>false</span>;      <br />&#160;&#160;&#160; }      <br />      <br />&#160;&#160;&#160; <span>// now check roles</span>      <br />&#160;&#160;&#160; <span>if</span> ( authorize )       <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span>// check user is authorized to execute the action</span>      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; authorize <span>=</span> AzManHelper.CheckAccess( cmd.Action, userName, azContext, azApp );      <br />&#160;&#160;&#160; }      <br />      <br />&#160;&#160;&#160; <span>if</span>( !authorize )      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span>throw</span> <span>new</span> TechException( Resource.ResourceManager[ Resource.MessageKey.NotAuthorized, cmd.Action, userName ] );      <br />&#160;&#160;&#160; }      <br />}      <br /></span></p>  <br />  <p>For an EDRA version you should change <em>cmd.Action</em> for <em>context.ServiceActionName</em> and throw a <em>BusinessRuleException</em> instead of a <em>TechException</em>.</p>  <br />  <p>I wrote an AzManHelper which helped abstract and encapsulate the AzMan api. I think the code is straightforward in terms of simplicity. We are doing this:</p>  <br />  <ol>   <br />    <li>IF the action being executed is excluded from configuration, just return to the pipeline. This is for actions that we want to bypass the access check.      <br /></li>    <li>Get the username from the current principal      <br /></li>    <li>Get the client context of AzMan for a given user and a given application (the application is the same that you created in the AzMan UI). If there was any problem getting the context set the flag to false      <br /></li>    <li>If the context was obtained, try the AccessCheck for the executing action, username and context      <br /></li>    <li>If it couldn't be authorized throw an exception</li> </ol>  <br />  <p>You can find the full source code for the handler: <a href="/blogs/matiaswoloski/content/binary/AzManHandler.zip">AzManHandler.zip (6.77 KB)</a></p>  <br />  <p>Thanks to <a href="/fwinkel">Federico Winkel</a> who helped a lot on this.</p>
